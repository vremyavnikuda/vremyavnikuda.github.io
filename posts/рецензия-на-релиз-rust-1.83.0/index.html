<!DOCTYPE html>
<html lang="en-us">

<head>
    <title>
Rust 1.83.0 Release | vremyavnikuda
</title>

    <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="Your website description">

<meta name="generator" content="Hugo 0.139.0">


<link rel="canonical" href="https://vremyavnikuda.github.io/posts/%D1%80%D0%B5%D1%86%D0%B5%D0%BD%D0%B7%D0%B8%D1%8F-%D0%BD%D0%B0-%D1%80%D0%B5%D0%BB%D0%B8%D0%B7-rust-1.83.0/" >




<link href="/css/style.min.36c061153203db94fc1169914d07c49c3a537a11316e9ffbd4c7a511df482d8d.css" rel="stylesheet">




</head>

<body>

    <div class="flexWrapper">
        <header class="headerWrapper">
    <div class="header">
        <div>
            <a class="terminal" href="https://vremyavnikuda.github.io/">
                <span>github.com/@vremyavnikuda ~ $</span>
            </a>
        </div>
        <input class="side-menu" type="checkbox" id="side-menu">
        <label class="hamb" for="side-menu"><span class="hamb-line"></span></label>
        <nav class="headerLinks">
            <ul>
                
                <li>
                    <a href="https://vremyavnikuda.github.io/about" title="" >
                        ~/about</a>
                </li>
                
                <li>
                    <a href="https://vremyavnikuda.github.io/posts" title="" >
                        ~/posts</a>
                </li>
                
            </ul>
        </nav>
    </div>
</header>


        <div class="content">
            <main class="main">
                
<div class="postWrapper">
    <h1>Rust 1.83.0 Release</h1>
    
    
    <section class="postMetadata">
        <dl>
            
            
            
            
            
                <dt>reading time</dt>
                <dd>4 minutes</dd>
            
        </dl>
    </section>
    
    <div>
        <p>Добавлены новые возможности для константных контекстов</p>
<p>Ссылки на статические переменные -&gt; Теперь константы могу ссылаться на неизменяемые статические переменный, что делает код более гибкими и уменьшает его количество ограничений при написании константных выражений.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> S: <span style="color:#66d9ef">i32</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">25</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> C: <span style="color:#66d9ef">&amp;</span><span style="color:#66d9ef">i32</span> <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>S;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() { println!(<span style="color:#e6db74">&#34;Значение константы: </span><span style="color:#e6db74">{}</span><span style="color:#e6db74">&#34;</span>, C); }
</span></span></code></pre></div><blockquote>
<p>но не будет работать так</p>
</blockquote>
<pre tabindex="0"><code>static mut S: i32 =0;
const C: &amp;i32 = &amp;S
</code></pre><blockquote>
<p>так как нельзя ссылаться на мутабельную переменную в константе</p>
</blockquote>
<hr>
<p>Появилась возможность использовать мутабельные ссылки и указатели в контексте констант, что значительно расширяет возможности работы с <code>const fn</code> и другими вычислениями на этапе компиляции.</p>
<p>Однако важно понимать, что эти мутабельные ссылки и указатели могут использоваться только внутри вычислений констант, но не могут быть частью конечного значения константы.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">inc</span>(x: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">mut</span> <span style="color:#66d9ef">i32</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">*</span>x <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">make_mutable_reference</span>() -&gt; <span style="color:#66d9ef">i32</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> val <span style="color:#f92672">=</span> <span style="color:#ae81ff">41</span>;
</span></span><span style="display:flex;"><span>    inc(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> val);
</span></span><span style="display:flex;"><span>    val
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> C: <span style="color:#66d9ef">i32</span> <span style="color:#f92672">=</span> make_mutable_reference();
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    println!(<span style="color:#e6db74">&#34;Значение константы C: </span><span style="color:#e6db74">{}</span><span style="color:#e6db74">&#34;</span>, C);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><blockquote>
<p>не нужно путать с примеров выше!!!</p>
</blockquote>
<p>Выражение, содержащее мутабельные ссылки, может быть вычислено на этапе компиляции, но нельзя использовать мутабельную ссылку как часть конечного значения константы:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> C: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">mut</span> <span style="color:#66d9ef">i32</span> <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> <span style="color:#ae81ff">4</span>; <span style="color:#75715e">// Ошибка: mutable references are not allowed in the final value of constants
</span></span></span></code></pre></div><p>мутабельный указатель в константном контексте</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">use</span> std::cell::UnsafeCell;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">modify_with_raw_pointer</span>() -&gt; <span style="color:#66d9ef">i32</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> c <span style="color:#f92672">=</span> UnsafeCell::new(<span style="color:#ae81ff">41</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">unsafe</span> { <span style="color:#f92672">*</span>c.get() <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span> };
</span></span><span style="display:flex;"><span>    c.into_inner()
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> C: <span style="color:#66d9ef">i32</span> <span style="color:#f92672">=</span> modify_with_raw_pointer();
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    println!(<span style="color:#e6db74">&#34;Значение константы C: </span><span style="color:#e6db74">{}</span><span style="color:#e6db74">&#34;</span>, C);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Но это все еще с ограничениями для обеспечения безопастности типов и предотвращения небезопасных операций.</p>
<hr>
<p>Стабилизация новых методов для коллекций</p>
<blockquote>
<p>Option::unwrap_unchecked</p>
</blockquote>
<blockquote>
<p>Option::replace</p>
</blockquote>
<p>расширяют возможности обработки значений, что делает код более выразительным и удобным.</p>
<p>Изменения касается стабилизации методов для работы с сырыми указателями и мутабельными ячейками, что указывает на улучшения для низкоуровневых операций и работы с памятью.</p>
<hr>
<p>Новые ошибки в <code>ErrorKind</code> улучшают поддержку работы с файловыми системами, что делает работу с низкоуровневыми операциями более безопасной и предсказуемой.</p>
<p>Оптимизированна работа</p>
<blockquote>
<p>ptr::replace</p>
</blockquote>
<blockquote>
<p>ptr::slice_from_raw_parts_mut</p>
</blockquote>
<p>для работы с сырыми указателями для модификации данных в массивах или срезах без необходимости копировать их.</p>
<hr>
<p>Исправлены</p>
<blockquote>
<p>slice::from_mut</p>
</blockquote>
<blockquote>
<p>slice::from_raw_parts_mut</p>
</blockquote>
<p>для работы с мутабельными срезами, позволяющие изменять данные в массивах или срезах без необходимости копировать их.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#75715e">//выглядит теперь это так
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">use</span> std::ptr;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> arr <span style="color:#f92672">=</span> [<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">5</span>];
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> ptr <span style="color:#f92672">=</span> arr.as_mut_ptr();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">unsafe</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> slice <span style="color:#f92672">=</span> std::slice::from_raw_parts_mut(ptr, arr.len());
</span></span><span style="display:flex;"><span>        slice[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>;
</span></span><span style="display:flex;"><span>        slice[<span style="color:#ae81ff">4</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">20</span>;
</span></span><span style="display:flex;"><span>        println!(<span style="color:#e6db74">&#34;Изменённый массив: </span><span style="color:#e6db74">{:?}</span><span style="color:#e6db74">&#34;</span>, arr); 
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Выведет: [10, 2, 3, 4, 20]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Обратите внимание что этот код находится внутри небезопастного блока <code>unsafe</code>,по скольку работа с сырыми указателями требует явного размешения на безопастный код.</p>
<hr>
<blockquote>
</blockquote>
<blockquote>
</blockquote>
<p>Эти методы позволяют безопасно получать мутабельные ссылки на первый и последний элементы среза или массива.
пример как теперь это работает</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> arr <span style="color:#f92672">=</span> [<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">5</span>];
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#66d9ef">let</span> Some(first) <span style="color:#f92672">=</span> arr.first_mut() {
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">*</span>first <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    println!(<span style="color:#e6db74">&#34;Изменённый массив: </span><span style="color:#e6db74">{:?}</span><span style="color:#e6db74">&#34;</span>, arr); 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Выведет: [10, 2, 3, 4, 5]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><hr>
<blockquote>
<p>Option::get_or_insert_default</p>
</blockquote>
<p>Теперь позволяет вставить значение по умолчанию в <code>Option</code>, если оно ещё не инициализировано (то есть если <code>Option</code> является <code>None</code>).</p>
<p>Эта функция полезна, например, при работе с кэшами, коллекциями или в ситуациях, где вы хотите гарантировать, что значение существует, и при необходимости инициализировать его значением по умолчанию.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">use</span> std::collections::HashMap;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> cache: Option<span style="color:#f92672">&lt;</span>HashMap<span style="color:#f92672">&lt;</span>String, <span style="color:#66d9ef">i32</span><span style="color:#f92672">&gt;&gt;</span> <span style="color:#f92672">=</span> None;
</span></span><span style="display:flex;"><span>    cache.get_or_insert_default().insert(<span style="color:#e6db74">&#34;apple&#34;</span>.to_string(), <span style="color:#ae81ff">5</span>);
</span></span><span style="display:flex;"><span>    cache.get_or_insert_default().insert(<span style="color:#e6db74">&#34;banana&#34;</span>.to_string(), <span style="color:#ae81ff">7</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#66d9ef">let</span> Some(map) <span style="color:#f92672">=</span> cache {
</span></span><span style="display:flex;"><span>        println!(<span style="color:#e6db74">&#34;Кэш: </span><span style="color:#e6db74">{:?}</span><span style="color:#e6db74">&#34;</span>, map);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//пример работы с вектором
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> nums: Option<span style="color:#f92672">&lt;</span>Vec<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">i32</span><span style="color:#f92672">&gt;&gt;</span> <span style="color:#f92672">=</span> None;
</span></span><span style="display:flex;"><span>    nums.get_or_insert_default().push(<span style="color:#ae81ff">10</span>);
</span></span><span style="display:flex;"><span>    nums.get_or_insert_default().push(<span style="color:#ae81ff">20</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#66d9ef">let</span> Some(vec) <span style="color:#f92672">=</span> nums {
</span></span><span style="display:flex;"><span>        println!(<span style="color:#e6db74">&#34;Вектор: </span><span style="color:#e6db74">{:?}</span><span style="color:#e6db74">&#34;</span>, vec);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><hr>
<p>Методы для работы с числами и строками:</p>
<blockquote>
<p>char::MIN:</p>
</blockquote>
<p>Минимальный символ, доступный в языке.</p>
<blockquote>
<p>{float}::classify</p>
</blockquote>
<blockquote>
<p>{float}::is_finite</p>
</blockquote>
<blockquote>
<p>{float}::is_infinite</p>
</blockquote>
<p>и другие:</p>
<p>Стабилизированные методы для работы с числами с плавающей точкой, включая проверку на бесконечность, нормальность и другие атрибуты.</p>
<hr>
<blockquote>
<p>str::as_mut_ptr
str::from_utf8_unchecked_mut</p>
</blockquote>
<p>Методы для работы с мутабельными строками, которые могут быть полезны в высокопроизводительных приложениях, где требуется манипуляция строками без излишних проверок.</p>
<p>как теперь это работает в 1.83.0</p>
<blockquote>
<p>f32::classify и f64::classify`</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> numbers <span style="color:#f92672">=</span> [<span style="color:#ae81ff">3.14</span>, <span style="color:#ae81ff">0.0</span>, <span style="color:#66d9ef">f32</span>::<span style="color:#66d9ef">INFINITY</span>, <span style="color:#66d9ef">f32</span>::<span style="color:#66d9ef">NEG_INFINITY</span>, <span style="color:#66d9ef">f32</span>::<span style="color:#66d9ef">NAN</span>];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#f92672">&amp;</span>num <span style="color:#66d9ef">in</span> <span style="color:#f92672">&amp;</span>numbers {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">match</span> num.classify() {
</span></span><span style="display:flex;"><span>            std::num::FpCategory::Normal <span style="color:#f92672">=&gt;</span> println!(<span style="color:#e6db74">&#34;Число </span><span style="color:#e6db74">{:?}</span><span style="color:#e6db74"> нормальное&#34;</span>, num),
</span></span><span style="display:flex;"><span>            std::num::FpCategory::Subnormal <span style="color:#f92672">=&gt;</span> println!(<span style="color:#e6db74">&#34;Число </span><span style="color:#e6db74">{:?}</span><span style="color:#e6db74"> поднормальное&#34;</span>, num),
</span></span><span style="display:flex;"><span>            std::num::FpCategory::Zero <span style="color:#f92672">=&gt;</span> println!(<span style="color:#e6db74">&#34;Число </span><span style="color:#e6db74">{:?}</span><span style="color:#e6db74"> равно нулю&#34;</span>, num),
</span></span><span style="display:flex;"><span>            std::num::FpCategory::Infinite <span style="color:#f92672">=&gt;</span> println!(<span style="color:#e6db74">&#34;Число </span><span style="color:#e6db74">{:?}</span><span style="color:#e6db74"> бесконечность&#34;</span>, num),
</span></span><span style="display:flex;"><span>            std::num::FpCategory::Nan <span style="color:#f92672">=&gt;</span> println!(<span style="color:#e6db74">&#34;Число </span><span style="color:#e6db74">{:?}</span><span style="color:#e6db74"> NaN&#34;</span>, num),
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">//Число 3.14 нормальное
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//Число 0.0 равно нулю
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//Число inf бесконечность
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//Число -inf бесконечность
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//Число NaN NaN
</span></span></span></code></pre></div><blockquote>
<p>f32::is_finite и f64::is_finite`</p>
</blockquote>
<p>Метод <code>is_finite</code> проверяет, является ли число конечным (не бесконечностью или <code>NaN</code>).</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> numbers <span style="color:#f92672">=</span> [<span style="color:#ae81ff">3.14</span>, <span style="color:#ae81ff">0.0</span>, <span style="color:#66d9ef">f32</span>::<span style="color:#66d9ef">INFINITY</span>, <span style="color:#66d9ef">f32</span>::<span style="color:#66d9ef">NEG_INFINITY</span>, <span style="color:#66d9ef">f32</span>::<span style="color:#66d9ef">NAN</span>];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#f92672">&amp;</span>num <span style="color:#66d9ef">in</span> <span style="color:#f92672">&amp;</span>numbers {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> num.is_finite() {
</span></span><span style="display:flex;"><span>            println!(<span style="color:#e6db74">&#34;Число </span><span style="color:#e6db74">{:?}</span><span style="color:#e6db74"> конечное&#34;</span>, num);
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>            println!(<span style="color:#e6db74">&#34;Число </span><span style="color:#e6db74">{:?}</span><span style="color:#e6db74"> не конечное&#34;</span>, num);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">//Число 3.14 конечное
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//Число 0.0 конечное
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//Число inf не конечное
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//Число -inf не конечное
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//Число NaN не конечное
</span></span></span></code></pre></div><blockquote>
<p>f32::is_infinite и f64::is_infinite`</p>
</blockquote>
<p>Метод <code>is_infinite</code> проверяет, является ли число бесконечностью (положительной или отрицательной).</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> numbers <span style="color:#f92672">=</span> [<span style="color:#ae81ff">3.14</span>, <span style="color:#ae81ff">0.0</span>, <span style="color:#66d9ef">f32</span>::<span style="color:#66d9ef">INFINITY</span>, <span style="color:#66d9ef">f32</span>::<span style="color:#66d9ef">NEG_INFINITY</span>, <span style="color:#66d9ef">f32</span>::<span style="color:#66d9ef">NAN</span>];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#f92672">&amp;</span>num <span style="color:#66d9ef">in</span> <span style="color:#f92672">&amp;</span>numbers {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> num.is_infinite() {
</span></span><span style="display:flex;"><span>            println!(<span style="color:#e6db74">&#34;Число </span><span style="color:#e6db74">{:?}</span><span style="color:#e6db74"> бесконечность&#34;</span>, num);
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>            println!(<span style="color:#e6db74">&#34;Число </span><span style="color:#e6db74">{:?}</span><span style="color:#e6db74"> не бесконечность&#34;</span>, num);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">//Число 3.14 не бесконечность
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//Число 0.0 не бесконечность
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//Число inf бесконечность
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//Число -inf бесконечность
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//Число NaN не бесконечность
</span></span></span></code></pre></div>
    </div>
</div>

            </main>
        </div>


        <footer class="footer">
    
        <span>
            © 2024 vremyavnikuda
        </span>
    
</footer>
    </div>

</body>

</html>