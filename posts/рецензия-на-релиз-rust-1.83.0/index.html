<!DOCTYPE html>
<html lang="en-us">

<head>
    <title>
 | vremyavnikuda
</title>

    <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="Your website description">

<meta name="generator" content="Hugo 0.139.0">


<link rel="canonical" href="https://vremyavnikuda.github.io/posts/%D1%80%D0%B5%D1%86%D0%B5%D0%BD%D0%B7%D0%B8%D1%8F-%D0%BD%D0%B0-%D1%80%D0%B5%D0%BB%D0%B8%D0%B7-rust-1.83.0/" >




<link href="/css/style.min.36c061153203db94fc1169914d07c49c3a537a11316e9ffbd4c7a511df482d8d.css" rel="stylesheet">




</head>

<body>

    <div class="flexWrapper">
        <header class="headerWrapper">
    <div class="header">
        <div>
            <a class="terminal" href="https://vremyavnikuda.github.io/">
                <span>github.com/@vremyavnikuda ~ $</span>
            </a>
        </div>
        <input class="side-menu" type="checkbox" id="side-menu">
        <label class="hamb" for="side-menu"><span class="hamb-line"></span></label>
        <nav class="headerLinks">
            <ul>
                
                <li>
                    <a href="https://vremyavnikuda.github.io/about" title="" >
                        ~/about</a>
                </li>
                
                <li>
                    <a href="https://vremyavnikuda.github.io/posts" title="" >
                        ~/posts</a>
                </li>
                
            </ul>
        </nav>
    </div>
</header>


        <div class="content">
            <main class="main">
                
<div class="postWrapper">
    <h1></h1>
    
    
    <section class="postMetadata">
        <dl>
            
            
            
            
            
        </dl>
    </section>
    
    <div>
        <p>Что в релизе 1.83.0</p>
<p>Добавлены новые возможности для константных контекстов
Ссылки на статические переменные -&gt; Теперь константы могу ссылаться на неизменяемые статические переменный, что делает код более гибкими и уменьшает его количество ограничений при написании константных выражений.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> S: <span style="color:#66d9ef">i32</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">25</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> C: <span style="color:#66d9ef">&amp;</span><span style="color:#66d9ef">i32</span> <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>S;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() { println!(<span style="color:#e6db74">&#34;Значение константы: </span><span style="color:#e6db74">{}</span><span style="color:#e6db74">&#34;</span>, C); }
</span></span></code></pre></div><p>Но не будет работать так</p>
<pre tabindex="0"><code>static mut S: i32 =0;
const C: &amp;i32 = &amp;S
</code></pre><p>Так как нельзя ссылаться на мутабельную переменную в константе</p>
<p>Появилась возможность использовать мутабельные ссылки и указатели в контексте констант, что значительно расширяет возможности работы с <code>const fn</code> и другими вычислениями на этапе компиляции. Однако важно понимать, что эти мутабельные ссылки и указатели могут использоваться только внутри вычислений констант, но не могут быть частью конечного значения константы.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">inc</span>(x: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">mut</span> <span style="color:#66d9ef">i32</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">*</span>x <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">make_mutable_reference</span>() -&gt; <span style="color:#66d9ef">i32</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> val <span style="color:#f92672">=</span> <span style="color:#ae81ff">41</span>;
</span></span><span style="display:flex;"><span>    inc(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> val);
</span></span><span style="display:flex;"><span>    val
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> C: <span style="color:#66d9ef">i32</span> <span style="color:#f92672">=</span> make_mutable_reference();
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    println!(<span style="color:#e6db74">&#34;Значение константы C: </span><span style="color:#e6db74">{}</span><span style="color:#e6db74">&#34;</span>, C);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>не нужно путать с примеров выше!!!
Выражение, содержащее мутабельные ссылки, может быть вычислено на этапе компиляции, но нельзя использовать мутабельную ссылку как часть конечного значения константы:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> C: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">mut</span> <span style="color:#66d9ef">i32</span> <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> <span style="color:#ae81ff">4</span>; <span style="color:#75715e">// Ошибка: mutable references are not allowed in the final value of constants
</span></span></span></code></pre></div><p>мутабельный указатель в константном контексте</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">use</span> std::cell::UnsafeCell;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">modify_with_raw_pointer</span>() -&gt; <span style="color:#66d9ef">i32</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> c <span style="color:#f92672">=</span> UnsafeCell::new(<span style="color:#ae81ff">41</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">unsafe</span> { <span style="color:#f92672">*</span>c.get() <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span> }; <span style="color:#75715e">// Используем сырое указательное API для изменения данных
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    c.into_inner()
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> C: <span style="color:#66d9ef">i32</span> <span style="color:#f92672">=</span> modify_with_raw_pointer();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    println!(<span style="color:#e6db74">&#34;Значение константы C: </span><span style="color:#e6db74">{}</span><span style="color:#e6db74">&#34;</span>, C);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Но это все еще с ограничениями для обеспечения безопастности типов и предотвращения небезопасных операций.
Стабилизация новых методов для коллекций <code>Option::unwrap_unchecked, Option::replace</code> расширяют возможности обработки значений, что делает код более выразительным и удобным.
Большая часть изменений касается стабилизации методов для работы с сырыми указателями и мутабельными ячейками, что указывает на улучшения для низкоуровневых операций и работы с памятью.
Новые ошибки в <code>ErrorKind</code> улучшают поддержку работы с файловыми системами, что делает работу с низкоуровневыми операциями более безопасной и предсказуемой.
Оптимизированна рабта <code>ptr::replace, ptr::slice_from_raw_parts_mut</code> для работы с сырыми указателями для модификации данных в массивах или срезах без необходимости копировать их.
Исправлены
<code>slice::from_mut, slice::from_raw_parts_mut</code>: для работы с мутабельными срезами, позволяющие изменять данные в массивах или срезах без необходимости копировать их.
выглядит теперь это так</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">use</span> std::ptr;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> arr <span style="color:#f92672">=</span> [<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">5</span>];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Получаем указатель на первый элемент массива
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">let</span> ptr <span style="color:#f92672">=</span> arr.as_mut_ptr();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Создаём мутабельный срез с помощью указателя и длины массива
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">unsafe</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> slice <span style="color:#f92672">=</span> std::slice::from_raw_parts_mut(ptr, arr.len());
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Изменяем элементы через срез
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        slice[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>;
</span></span><span style="display:flex;"><span>        slice[<span style="color:#ae81ff">4</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">20</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        println!(<span style="color:#e6db74">&#34;Изменённый массив: </span><span style="color:#e6db74">{:?}</span><span style="color:#e6db74">&#34;</span>, arr); <span style="color:#75715e">// Выведет: [10, 2, 3, 4, 20]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Обратите внимание что этот код находится внутри небезопастного блока <code>unsafe</code>,по скольку работа с сырыми указателями требует явного размешения на безопастный код.</p>
<p><code>[_]::first_mut, [_]::last_mut</code>: Эти методы позволяют безопасно получать мутабельные ссылки на первый и последний элементы среза или массива.
пример как теперь это работает</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> arr <span style="color:#f92672">=</span> [<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">5</span>];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Получаем мутабельную ссылку на первый элемент массива
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#66d9ef">let</span> Some(first) <span style="color:#f92672">=</span> arr.first_mut() {
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">*</span>first <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>; <span style="color:#75715e">// Изменяем значение первого элемента
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    println!(<span style="color:#e6db74">&#34;Изменённый массив: </span><span style="color:#e6db74">{:?}</span><span style="color:#e6db74">&#34;</span>, arr); <span style="color:#75715e">// Выведет: [10, 2, 3, 4, 5]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p><code>Option::get_or_insert_default</code>
Теперь позволяет вставить значение по умолчанию в <code>Option</code>, если оно ещё не инициализировано (то есть если <code>Option</code> является <code>None</code>). Эта функция полезна, например, при работе с кэшами, коллекциями или в ситуациях, где вы хотите гарантировать, что значение существует, и при необходимости инициализировать его значением по умолчанию.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">use</span> std::collections::HashMap;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> cache: Option<span style="color:#f92672">&lt;</span>HashMap<span style="color:#f92672">&lt;</span>String, <span style="color:#66d9ef">i32</span><span style="color:#f92672">&gt;&gt;</span> <span style="color:#f92672">=</span> None;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Вставляем новый HashMap, если cache не инициализирована
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    cache.get_or_insert_default().insert(<span style="color:#e6db74">&#34;apple&#34;</span>.to_string(), <span style="color:#ae81ff">5</span>);
</span></span><span style="display:flex;"><span>    cache.get_or_insert_default().insert(<span style="color:#e6db74">&#34;banana&#34;</span>.to_string(), <span style="color:#ae81ff">7</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Выводим содержимое HashMap
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#66d9ef">let</span> Some(map) <span style="color:#f92672">=</span> cache {
</span></span><span style="display:flex;"><span>        println!(<span style="color:#e6db74">&#34;Кэш: </span><span style="color:#e6db74">{:?}</span><span style="color:#e6db74">&#34;</span>, map);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>пример с вектором:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> nums: Option<span style="color:#f92672">&lt;</span>Vec<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">i32</span><span style="color:#f92672">&gt;&gt;</span> <span style="color:#f92672">=</span> None;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Вставляем новый вектор, если nums не инициализирован
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    nums.get_or_insert_default().push(<span style="color:#ae81ff">10</span>);
</span></span><span style="display:flex;"><span>    nums.get_or_insert_default().push(<span style="color:#ae81ff">20</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Выводим содержимое вектора
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#66d9ef">let</span> Some(vec) <span style="color:#f92672">=</span> nums {
</span></span><span style="display:flex;"><span>        println!(<span style="color:#e6db74">&#34;Вектор: </span><span style="color:#e6db74">{:?}</span><span style="color:#e6db74">&#34;</span>, vec);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Методы для работы с числами и строками:</p>
<p><code>char::MIN:</code> Минимальный символ, доступный в языке.
<code>{float}::classify, {float}::is_finite, {float}::is_infinite</code> и другие: Стабилизированные методы для работы с числами с плавающей точкой, включая проверку на бесконечность, нормальность и другие атрибуты.
<code>str::as_mut_ptr, str::from_utf8_unchecked_mut</code>: Методы для работы с мутабельными строками, которые могут быть полезны в высокопроизводительных приложениях, где требуется манипуляция строками без излишних проверок.
как теперь это работает в 1.83.0
<code>f32::classify и f64::classify</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> numbers <span style="color:#f92672">=</span> [<span style="color:#ae81ff">3.14</span>, <span style="color:#ae81ff">0.0</span>, <span style="color:#66d9ef">f32</span>::<span style="color:#66d9ef">INFINITY</span>, <span style="color:#66d9ef">f32</span>::<span style="color:#66d9ef">NEG_INFINITY</span>, <span style="color:#66d9ef">f32</span>::<span style="color:#66d9ef">NAN</span>];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#f92672">&amp;</span>num <span style="color:#66d9ef">in</span> <span style="color:#f92672">&amp;</span>numbers {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">match</span> num.classify() {
</span></span><span style="display:flex;"><span>            std::num::FpCategory::Normal <span style="color:#f92672">=&gt;</span> println!(<span style="color:#e6db74">&#34;Число </span><span style="color:#e6db74">{:?}</span><span style="color:#e6db74"> нормальное&#34;</span>, num),
</span></span><span style="display:flex;"><span>            std::num::FpCategory::Subnormal <span style="color:#f92672">=&gt;</span> println!(<span style="color:#e6db74">&#34;Число </span><span style="color:#e6db74">{:?}</span><span style="color:#e6db74"> поднормальное&#34;</span>, num),
</span></span><span style="display:flex;"><span>            std::num::FpCategory::Zero <span style="color:#f92672">=&gt;</span> println!(<span style="color:#e6db74">&#34;Число </span><span style="color:#e6db74">{:?}</span><span style="color:#e6db74"> равно нулю&#34;</span>, num),
</span></span><span style="display:flex;"><span>            std::num::FpCategory::Infinite <span style="color:#f92672">=&gt;</span> println!(<span style="color:#e6db74">&#34;Число </span><span style="color:#e6db74">{:?}</span><span style="color:#e6db74"> бесконечность&#34;</span>, num),
</span></span><span style="display:flex;"><span>            std::num::FpCategory::Nan <span style="color:#f92672">=&gt;</span> println!(<span style="color:#e6db74">&#34;Число </span><span style="color:#e6db74">{:?}</span><span style="color:#e6db74"> NaN&#34;</span>, num),
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><pre tabindex="0"><code>Число 3.14 нормальное
Число 0.0 равно нулю
Число inf бесконечность
Число -inf бесконечность
Число NaN NaN
</code></pre><p><code>f32::is_finite и f64::is_finite</code>
Метод <code>is_finite</code> проверяет, является ли число конечным (не бесконечностью или <code>NaN</code>).</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> numbers <span style="color:#f92672">=</span> [<span style="color:#ae81ff">3.14</span>, <span style="color:#ae81ff">0.0</span>, <span style="color:#66d9ef">f32</span>::<span style="color:#66d9ef">INFINITY</span>, <span style="color:#66d9ef">f32</span>::<span style="color:#66d9ef">NEG_INFINITY</span>, <span style="color:#66d9ef">f32</span>::<span style="color:#66d9ef">NAN</span>];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#f92672">&amp;</span>num <span style="color:#66d9ef">in</span> <span style="color:#f92672">&amp;</span>numbers {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> num.is_finite() {
</span></span><span style="display:flex;"><span>            println!(<span style="color:#e6db74">&#34;Число </span><span style="color:#e6db74">{:?}</span><span style="color:#e6db74"> конечное&#34;</span>, num);
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>            println!(<span style="color:#e6db74">&#34;Число </span><span style="color:#e6db74">{:?}</span><span style="color:#e6db74"> не конечное&#34;</span>, num);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><code>Число 3.14 конечное Число 0.0 конечное Число inf не конечное Число -inf не конечное Число NaN не конечное</code>
<code>f32::is_infinite и f64::is_infinite</code>
Метод <code>is_infinite</code> проверяет, является ли число бесконечностью (положительной или отрицательной).</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> numbers <span style="color:#f92672">=</span> [<span style="color:#ae81ff">3.14</span>, <span style="color:#ae81ff">0.0</span>, <span style="color:#66d9ef">f32</span>::<span style="color:#66d9ef">INFINITY</span>, <span style="color:#66d9ef">f32</span>::<span style="color:#66d9ef">NEG_INFINITY</span>, <span style="color:#66d9ef">f32</span>::<span style="color:#66d9ef">NAN</span>];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#f92672">&amp;</span>num <span style="color:#66d9ef">in</span> <span style="color:#f92672">&amp;</span>numbers {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> num.is_infinite() {
</span></span><span style="display:flex;"><span>            println!(<span style="color:#e6db74">&#34;Число </span><span style="color:#e6db74">{:?}</span><span style="color:#e6db74"> бесконечность&#34;</span>, num);
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>            println!(<span style="color:#e6db74">&#34;Число </span><span style="color:#e6db74">{:?}</span><span style="color:#e6db74"> не бесконечность&#34;</span>, num);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><code>Число 3.14 не бесконечность Число 0.0 не бесконечность Число inf бесконечность Число -inf бесконечность Число NaN не бесконечность</code></p>

    </div>
</div>

            </main>
        </div>


        <footer class="footer">
    
        <span>
            © 2024 vremyavnikuda, Built with
            <a href="https://gohugo.io" class="footerLink">Hugo</a> and
            <a href="https://github.com/LordMathis/hugo-theme-nightfall" class="footerLink">Nightfall</a> theme
        </span>
    
</footer>
    </div>

</body>

</html>